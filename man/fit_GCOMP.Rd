% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tmle.R
\name{fit_GCOMP}
\alias{fit_GCOMP}
\title{Fit sequential GCOMP and TMLE for survival}
\usage{
fit_GCOMP(
  OData,
  tvals,
  Qforms,
  intervened_TRT = NULL,
  intervened_MONITOR = NULL,
  rule_name = paste0(c(intervened_TRT, intervened_MONITOR), collapse = ""),
  models = NULL,
  fit_method = stremrOptions("fit_method"),
  fold_column = stremrOptions("fold_column"),
  TMLE = FALSE,
  stratifyQ_by_rule = FALSE,
  stratify_by_last = TRUE,
  Qstratify = NULL,
  useonly_t_TRT = NULL,
  useonly_t_MONITOR = NULL,
  iterTMLE = FALSE,
  CVTMLE = FALSE,
  byfold_Q = FALSE,
  IPWeights = NULL,
  trunc_weights = 10^6,
  weights = NULL,
  max_iter = 15,
  adapt_stop = TRUE,
  adapt_stop_factor = 10,
  tol_eps = 0.001,
  parallel = FALSE,
  return_wts = FALSE,
  return_fW = FALSE,
  reg_Q = NULL,
  intervened_type_TRT = NULL,
  intervened_type_MONITOR = NULL,
  maxpY = 1,
  TMLE_updater = "TMLE.updater.speedglm",
  verbose = getOption("stremr.verbose"),
  ...
)
}
\arguments{
\item{OData}{Input data object created by \code{importData} function.}

\item{tvals}{Vector of time-points in the data for which the survival function (and risk) should be estimated}

\item{Qforms}{Regression formulas, one formula per Q. Only main-terms are allowed.}

\item{intervened_TRT}{Column name in the input data with the probabilities (or indicators) of counterfactual treatment nodes being equal to 1 at each time point.
Leave the argument unspecified (\code{NULL}) when not intervening on treatment node(s).}

\item{intervened_MONITOR}{Column name in the input data with probabilities (or indicators) of counterfactual monitoring nodes being equal to 1 at each time point.
Leave the argument unspecified (\code{NULL}) when not intervening on the monitoring node(s).}

\item{rule_name}{Optional name for the treatment/monitoring regimen.}

\item{models}{Optional parameters specifying the models for fitting the iterative (sequential) G-Computation formula.
Must be an object of class \code{ModelStack} specified with \code{gridisl::defModel} function.}

\item{fit_method}{Model selection approach. Can be either \code{"none"} - no model selection or
\code{"cv"} - discrete Super Learner using V fold cross-validation that selects the best model according to lowest cross-validated MSE (must specify the column name that contains the fold IDs) or
\code{"origamiSL"} - continuous Super Learner that uses the \code{origami} R package to select the
convex combination of the model predictions (aka model stacking).}

\item{fold_column}{The column name in the input data (ordered factor) that contains the fold IDs to be used as part of the validation sample.
Use the provided function \code{\link{define_CVfolds}} to
define such folds or define the folds using your own method.}

\item{TMLE}{Set to \code{TRUE} to run the usual longitudinal TMLE algorithm (with a separate TMLE update of Q for every sequential regression).}

\item{stratifyQ_by_rule}{Set to \code{TRUE} for stratifying the fit of Q (the outcome model) by rule-followers only.
There are two ways to do this stratification. The first option is to use \code{stratify_by_last=TRUE}  (default),
which would fit the outcome model only among the observations that were receiving their supposed
counterfactual treatment at the current time-point (ignoring the past history of treatments leading up to time-point t).
The second option is to set \code{stratify_by_last=FALSE} in which case the outcome model will be fit only
among the observations who followed their counterfactual treatment regimen throughout the entire treatment history up to
current time-point t (rule followers). For the latter option, the observation would be considered a non-follower if
the person's treatment did not match their supposed counterfactual treatment at any time-point up to and including current
time-point t.}

\item{stratify_by_last}{Only used when \code{stratifyQ_by_rule} is \code{TRUE}.
Set to \code{TRUE} for stratification by last time-point, set to \code{FALSE} for stratification by all time-points (rule-followers).
See \code{stratifyQ_by_rule} for more details.}

\item{Qstratify}{Placeholder for future user-defined model stratification for fitting Qs (CURRENTLY NOT FUNCTIONAL, WILL RESULT IN ERROR).}

\item{useonly_t_TRT}{Use for intervening only on some subset of observation and time-specific treatment nodes.
Should be a character string with a logical expression that defines the subset of intervention observations.
For example, using \code{TRT==0} will intervene only at observations with the value of \code{TRT} being equal to zero.
The expression can contain any variable name that was defined in the input dataset.
Leave as \code{NULL} when intervening on all observations/time-points.}

\item{useonly_t_MONITOR}{Same as \code{useonly_t_TRT}, but for monitoring nodes.}

\item{iterTMLE}{Set to \code{TRUE} to run the iterative univariate TMLE instead of the usual longitudinal TMLE.
When set to \code{TRUE} this will also provide the standard sequential Gcomp as party of the output.}

\item{CVTMLE}{Set to \code{TRUE} to run the CV-TMLE algorithm instead of the usual TMLE algorithm.
Must set either \code{TMLE}=\code{TRUE} or \code{iterTMLE}=\code{TRUE} for this argument to have any effect.}

\item{byfold_Q}{(ADVANCED USE) Fit iterative means (Q parameter) using "by-fold" (aka "fold-specific" or "split-specific") cross-validation approach.
Only works with \code{fit_method}=\code{"origamiSL"}.}

\item{IPWeights}{(Optional) result of calling function \code{getIPWeights} for running TMLE (evaluated automatically when missing)}

\item{trunc_weights}{Specify the numeric weight truncation value. All final weights exceeding the value in \code{trunc_weights} will be truncated.}

\item{weights}{Optional \code{data.table} with additional observation- and time-specific weights.  Must contain columns \code{ID}, \code{t} and \code{weight}.
The column named \code{weight} is merged back into the original data according to (\code{ID}, \code{t}). Not implemented yet.}

\item{max_iter}{For iterative TMLE only: Integer, set to maximum number of iterations for iterative TMLE algorithm.}

\item{adapt_stop}{For iterative TMLE only: Choose between two stopping criteria for iterative TMLE, default is \code{TRUE},
which will stop the iterative TMLE algorithm in an adaptive way. Specifically, the iterations will stop when the mean estimate
of the efficient influence curve is less than or equal to 1 / (\code{adapt_stop_factor}*sqrt(\code{N})), where
N is the total number of unique subjects in data and \code{adapt_stop_factor} is set to 10 by default.
When \code{TRUE}, the argument \code{tol_eps} is ignored and TMLE stops when either \code{max_iter} has been reached or this criteria has been satisfied.
When \code{FALSE}, the stopping criteria is determined by values of \code{max_iter} and \code{tol_eps}.}

\item{adapt_stop_factor}{For iterative TMLE only: The adaptive factor to choose the stopping criteria for iterative TMLE when
\code{adapt_stop} is set to \code{TRUE}. Default is 10.
TMLE will keep iterative until
the mean estimate of the efficient influence curve is less than 1 / (\code{adapt_stop_factor}*sqrt(\code{N})) or when the number of iterations is \code{max_iter}.}

\item{tol_eps}{For iterative TMLE only: Numeric error tolerance for the iterative TMLE update.
The iterative TMLE algorithm will stop when the absolute value of the TMLE intercept update is below \code{tol_eps}}

\item{parallel}{Set to \code{TRUE} to run the sequential G-COMP or TMLE in parallel (uses \code{foreach} with \code{dopar} and
requires a previously defined parallel back-end cluster)}

\item{return_wts}{Applies only when \code{TMLE = TRUE}.
Return the data.table with subject-specific IP weights as part of the output.
Note: for large datasets setting this to \code{TRUE} may lead to extremely large object sizes!}

\item{return_fW}{When \code{TRUE}, will return the object fit for the last Q regression as part of the output table.
Can be used for obtaining subject-specific predictions of the counterfactual functional E(Y_{d}|W_i).}

\item{reg_Q}{(ADVANCED USE ONLY) Directly specify the Q regressions, separately for each time-point.}

\item{intervened_type_TRT}{(ADVANCED FUNCTIONALITY) Set to \code{NULL} by default, can be characters that are set to either 
\code{"bin"}, \code{"shift"} or \code{"MSM"}. 
Provides support for different types of interventions on \code{TRT} (treatment) node (counterfactual treatment node \code{A^*(t)}).
The default behavior is the same as \code{"bin"}, which assumes that \code{A^*(t)} is binary and 
is set equal to either \code{0}, \code{1} or \code{p(t)}, where 0<=\code{p(t)}<=1. 
Here, \code{p(t)} denotes the probability that counterfactual A^*(t) is equal to 1, i.e., P(A^*(t)=1)=\code{p(t)} 
and it can change in time and subject to subject.
For \code{"shift"}, it is assumed that the intervention node \code{A^*(t)} is a shift in the value of the continuous treatment \code{A}, 
i.e., \code{A^*(t)}=\code{A(t)}+delta(t).
Finally, for "MSM" it is assumed that we simply want the final intervention density \code{g^*(t)} to be set to a constant 1. 
This has use for static MSMs.}

\item{intervened_type_MONITOR}{(ADVANCED FUNCTIONALITY) Same as \code{intervened_type_TRT}, but for monitoring intervention node 
(counterfactual monitoring node \code{N^*(t)}).}

\item{maxpY}{Maximum probability that the cumulative incidence of the outcome Y(t) is equal to 1.
Useful for upper-bounding the rare-outcomes.}

\item{TMLE_updater}{Function for performing the TMLE update. Default is the TMLE updater based on speedglm (called \code{"TMLE.updater.speedglm"}).
Other possible options include \code{"TMLE.updater.glm"}, \code{"linear.TMLE.updater.speedglm"} and \code{"iTMLE.updater.xgb"}.}

\item{verbose}{Set to \code{TRUE} to print auxiliary messages during model fitting.}

\item{...}{When \code{models} arguments is NOT specified, these additional arguments will be passed on directly to all \code{GridSL}
modeling functions that are called from this routine,
e.g., \code{family = "binomial"} can be used to specify the model family.
Note that all such arguments must be named.}
}
\value{
An output list containing the \code{data.table} with survival estimates over time saved as \code{"estimates"}.
}
\description{
Interventions on up to 3 nodes are allowed: \code{CENS}, \code{TRT} and \code{MONITOR}.
TMLE adjustment will be based on the inverse of the propensity score fits for the observed likelihood (g0.C, g0.A, g0.N),
multiplied by the indicator of not being censored and the probability of each intervention in \code{intervened_TRT} and \code{intervened_MONITOR}.
Requires column name(s) that specify the counterfactual node values or the counterfactual probabilities of each node being 1 (for stochastic interventions).
}
\examples{
options(stremr.verbose = TRUE)
require("data.table")

# ----------------------------------------------------------------------
# Simulated Data
# ----------------------------------------------------------------------
data(OdataNoCENS)
OdataDT <- as.data.table(OdataNoCENS, key=c("ID", "t"))

# define lagged N, first value is always 1 (always monitored at the first time point):
OdataDT[, ("N.tminus1") := shift(get("N"), n = 1L, type = "lag", fill = 1L), by = ID]
OdataDT[, ("TI.tminus1") := shift(get("TI"), n = 1L, type = "lag", fill = 1L), by = ID]

# ----------------------------------------------------------------------
# Define intervention (always treated):
# ----------------------------------------------------------------------
OdataDT[, ("TI.set1") := 1L]
OdataDT[, ("TI.set0") := 0L]

# ----------------------------------------------------------------------
# Import Data
# ----------------------------------------------------------------------
OData <- importData(OdataDT, ID = "ID", t = "t", covars = c("highA1c", "lastNat1", "N.tminus1"),
                    CENS = "C", TRT = "TI", MONITOR = "N", OUTCOME = "Y.tplus1")

# ----------------------------------------------------------------------
# Look at the input data object
# ----------------------------------------------------------------------
print(OData)

# ----------------------------------------------------------------------
# Access the input data
# ----------------------------------------------------------------------
get_data(OData)

# ----------------------------------------------------------------------
# Model the Propensity Scores
# ----------------------------------------------------------------------
gform_CENS <- "C ~ highA1c + lastNat1"
gform_TRT = "TI ~ CVD + highA1c + N.tminus1"
gform_MONITOR <- "N ~ 1"
stratify_CENS <- list(C=c("t < 16", "t == 16"))

# ----------------------------------------------------------------------
# Fit Propensity Scores
# ----------------------------------------------------------------------
OData <- fitPropensity(OData, gform_CENS = gform_CENS,
                        gform_TRT = gform_TRT,
                        gform_MONITOR = gform_MONITOR,
                        stratify_CENS = stratify_CENS)

# ----------------------------------------------------------------------
# IPW Ajusted KM or Saturated MSM
# ----------------------------------------------------------------------
require("magrittr")
AKME.St.1 <- getIPWeights(OData, intervened_TRT = "TI.set1") \%>\%
             survNPMSM(OData) \%$\%
             estimates
AKME.St.1

# ----------------------------------------------------------------------
# Bounded IPW
# ----------------------------------------------------------------------
IPW.St.1 <- getIPWeights(OData, intervened_TRT = "TI.set1") \%>\%
            directIPW(OData)
IPW.St.1[]

# ----------------------------------------------------------------------
# IPW-MSM for hazard
# ----------------------------------------------------------------------
wts.DT.1 <- getIPWeights(OData = OData, intervened_TRT = "TI.set1", rule_name = "TI1")
wts.DT.0 <- getIPWeights(OData = OData, intervened_TRT = "TI.set0", rule_name = "TI0")
survMSM_res <- survMSM(list(wts.DT.1, wts.DT.0), OData, tbreaks = c(1:8,12,16)-1,)
survMSM_res$St

# ----------------------------------------------------------------------
# Sequential G-COMP
# ----------------------------------------------------------------------
t.surv <- c(0:10)
Qforms <- rep.int("Qkplus1 ~ CVD + highA1c + N + lastNat1 + TI + TI.tminus1", (max(t.surv)+1))
params <- gridisl::defModel(estimator = "speedglm__glm")

\dontrun{
gcomp_est <- fit_GCOMP(OData, tvals = t.surv, intervened_TRT = "TI.set1",
                          Qforms = Qforms, models = params, stratifyQ_by_rule = FALSE)
gcomp_est[]
}
# ----------------------------------------------------------------------
# TMLE
# ----------------------------------------------------------------------
\dontrun{
tmle_est <- fit_TMLE(OData, tvals = t.surv, intervened_TRT = "TI.set1",
                    Qforms = Qforms, models = params, stratifyQ_by_rule = TRUE)
tmle_est[]
}

# ----------------------------------------------------------------------
# Running IPW-Adjusted KM with optional user-specified weights:
# ----------------------------------------------------------------------
addedWts_DT <- OdataDT[, c("ID", "t"), with = FALSE]
addedWts_DT[, new.wts := sample.int(10, nrow(OdataDT), replace = TRUE)/10]
survNP_res_addedWts <- survNPMSM(wts.DT.1, OData, weights = addedWts_DT)

# ----------------------------------------------------------------------
# Multivariate Propensity Score Regressions
# ----------------------------------------------------------------------
gform_CENS <- "C + TI + N ~ highA1c + lastNat1"
OData <- fitPropensity(OData, gform_CENS = gform_CENS, gform_TRT = gform_TRT,
                        gform_MONITOR = gform_MONITOR)

# ----------------------------------------------------------------------
# Fitting treatment model with Gradient Boosting machines:
# ----------------------------------------------------------------------
\dontrun{
require("h2o")
h2o::h2o.init(nthreads = -1)
gform_CENS <- "C ~ highA1c + lastNat1"
models_TRT <- sl3::Lrnr_h2o_grid$new(algorithm = "gbm")
OData <- fitPropensity(OData, gform_CENS = gform_CENS,
                        gform_TRT = gform_TRT,
                        models_TRT = models_TRT,
                        gform_MONITOR = gform_MONITOR,
                        stratify_CENS = stratify_CENS)

# Use `H2O-3` distributed implementation of GLM for treatment model estimator:
models_TRT <- sl3::Lrnr_h2o_glm$new(family = "binomial")
OData <- fitPropensity(OData, gform_CENS = gform_CENS,
                        gform_TRT = gform_TRT,
                        models_TRT = models_TRT,
                        gform_MONITOR = gform_MONITOR,
                        stratify_CENS = stratify_CENS)

# Use Deep Neural Nets:
models_TRT <- sl3::Lrnr_h2o_grid$new(algorithm = "deeplearning")
OData <- fitPropensity(OData, gform_CENS = gform_CENS,
                        gform_TRT = gform_TRT,
                        models_TRT = models_TRT,
                        gform_MONITOR = gform_MONITOR,
                        stratify_CENS = stratify_CENS)
}

# ----------------------------------------------------------------------
# Fitting different models with different algorithms
# Fine tuning modeling with optional tuning parameters.
# ----------------------------------------------------------------------
\dontrun{
params_TRT <- sl3::Lrnr_h2o_grid$new(algorithm = "gbm",
                              ntrees = 50,
                              learn_rate = 0.05,
                              sample_rate = 0.8,
                              col_sample_rate = 0.8,
                              balance_classes = TRUE)
params_CENS <- sl3::Lrnr_glm_fast$new()
params_MONITOR <- sl3::Lrnr_glm_fast$new()
OData <- fitPropensity(OData,
            gform_CENS = gform_CENS, stratify_CENS = stratify_CENS, params_CENS = params_CENS,
            gform_TRT = gform_TRT, params_TRT = params_TRT,
            gform_MONITOR = gform_MONITOR, params_MONITOR = params_MONITOR)
}

# ----------------------------------------------------------------------
# Running TMLE based on the previous fit of the propensity scores.
# Also applying Random Forest to estimate the sequential outcome model
# ----------------------------------------------------------------------
\dontrun{
t.surv <- c(0:5)
Qforms <- rep.int("Qkplus1 ~ CVD + highA1c + N + lastNat1 + TI + TI.tminus1", (max(t.surv)+1))
models <- sl3::Lrnr_h2o_grid$new(algorithm = "randomForest",
                           ntrees = 100, learn_rate = 0.05, sample_rate = 0.8,
                           col_sample_rate = 0.8, balance_classes = TRUE)
tmle_est <- fit_TMLE(OData, tvals = t.surv, intervened_TRT = "TI.set1",
            Qforms = Qforms, models = models,
            stratifyQ_by_rule = TRUE)
}

\dontrun{
t.surv <- c(0:5)
Qforms <- rep.int("Qkplus1 ~ CVD + highA1c + N + lastNat1 + TI + TI.tminus1", (max(t.surv)+1))
models <- sl3::Lrnr_h2o_grid$new(algorithm = "randomForest",
                           ntrees = 100, learn_rate = 0.05, sample_rate = 0.8,
                           col_sample_rate = 0.8, balance_classes = TRUE)
tmle_est <- fit_TMLE(OData, tvals = t.surv, intervened_TRT = "TI.set1",
            Qforms = Qforms, models = models,
            stratifyQ_by_rule = FALSE)
}

}
\seealso{
\code{\link{stremr-package}} for the general overview of the package.
}
